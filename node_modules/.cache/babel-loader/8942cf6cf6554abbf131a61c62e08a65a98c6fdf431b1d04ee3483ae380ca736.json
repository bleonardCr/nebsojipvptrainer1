{"ast":null,"code":"// src/engine/battleEngine.js\n// Minimal, accurate PvP simulator core for �who wins�\n// Assumes you pass in Pokemon + moves sourced from a PvP-ready gamemaster (PvPoke format is ideal).\n\n/* ===================== Data plumbing ===================== */\n\n// CPM table (levels 1.0 ... 51.0 in 0.5 steps). Truncated here; include full table you already use.\nexport const CPM = {\n  \"40\": 0.79030001,\n  \"41\": 0.79530001,\n  \"50\": 0.84029999,\n  \"51\": 0.84529999\n  // <-- Replace with your full CPM table for all supported levels\n};\n\n// Simple type chart (multiplier). Fill with full chart in your project.\n// Example: typeChart['ground']['electric'] === 1.6, typeChart['electric']['ground'] === 0.625, etc.\nexport const typeChart = {\n  normal: {\n    rock: 0.625,\n    ghost: 0.390625,\n    steel: 0.625\n  },\n  fire: {\n    fire: 0.625,\n    water: 0.625,\n    grass: 1.6,\n    ice: 1.6,\n    bug: 1.6,\n    rock: 0.625,\n    dragon: 0.625,\n    steel: 1.6\n  },\n  water: {\n    fire: 1.6,\n    water: 0.625,\n    grass: 0.625,\n    ground: 1.6,\n    rock: 1.6,\n    dragon: 0.625\n  }\n  // ... complete all 18 types\n};\n\n/* ===================== Helpers ===================== */\n\nfunction clamp(v, min, max) {\n  return Math.max(min, Math.min(max, v));\n}\nfunction stabMultiplier(moveType, monTypes) {\n  return monTypes.includes(moveType) ? 1.2 : 1.0; // STAB\n}\nfunction typeEffectiveness(moveType, defenderTypes) {\n  let mult = 1.0;\n  for (const t of defenderTypes) {\n    var _row$t;\n    const row = typeChart[moveType] || {};\n    mult *= (_row$t = row[t]) !== null && _row$t !== void 0 ? _row$t : 1.0;\n  }\n  return mult;\n}\nexport function trueStats(base, iv, level, isShadow = false) {\n  // Attack/Defense/HP for PvP\n  const cpm = CPM[String(level)];\n  if (!cpm) throw new Error(`Missing CPM for level ${level}`);\n  // Shadow: Atk *1.2, Def *0.833333... (approx), modeled as per Niantic; tweak if your dataset encodes it differently.\n  const atkMult = isShadow ? 1.2 : 1.0;\n  const defMult = isShadow ? 5 / 6 : 1.0;\n  const atk = (base.atk + iv.atk) * cpm * atkMult;\n  const def = (base.def + iv.def) * cpm * defMult;\n  const hp = Math.floor((base.hp + iv.hp) * cpm);\n  return {\n    atk,\n    def,\n    hp: Math.max(1, hp)\n  };\n}\nexport function pvpDamage(power, atk, def, stab, eff, stageMult = 1.0) {\n  // Floor(0.5 * Power * (Atk/Def) * STAB * Effectiveness * stageMult) + 1\n  // stageMult is the combined buff/debuff multiplier (attack vs defense stages)\n  const raw = 0.5 * power * (atk / def) * stab * eff * stageMult;\n  return Math.floor(raw) + 1;\n}\n\n// Convert stages to multipliers (each stage ~10% in PvP; Niantic uses hidden multipliers)\n// Commonly modeled as: stage: -4..+4 -> multipliers [see PvPoke]. Here�s a typical table:\nconst STAGE_MULT = [0.5, 0.571, 0.667, 0.8, 1.0, 1.25, 1.5, 1.75, 2.0]; // index 0..8 maps to -4..+4\nfunction stageIndexFromDelta(delta) {\n  return clamp(delta + 4, 0, 8);\n}\nfunction stagePairMultiplier(atkStages, defStages) {\n  const a = STAGE_MULT[stageIndexFromDelta(atkStages)];\n  const d = STAGE_MULT[stageIndexFromDelta(defStages)];\n  return a / d;\n}\n\n/* ===================== Core simulator ===================== */\n\n/**\r\n * move objects expected shape (PvP values):\r\n * fastMove: { id, type, power, energyGain, durationTurns }\r\n * chargedMoves: [{ id, type, power, energyCost, buff?: { target:\"self\"|\"opponent\", atkDelta?:number, defDelta?:number, applyChance?:number } }]\r\n */\nexport function simulateBattle(p1, p2, opts = {}) {\n  var _opts$maxTurns;\n  // p1/p2: { name, types:[t1,t2?], base:{atk,def,hp}, iv:{atk,def,hp}, level, isShadow, fastMove, chargedMoves:[...], shields }\n  const MAX_TURNS = (_opts$maxTurns = opts.maxTurns) !== null && _opts$maxTurns !== void 0 ? _opts$maxTurns : 1000; // 1000 turns = 500s > 240s hard clock, fine for result\n  const p1s = initSide(p1);\n  const p2s = initSide(p2);\n\n  // CMP: true Attack decides who throws first when both use a charged move on the same turn\n  const cmpFirst = p1s.stats.atk === p2s.stats.atk ? p1.name <= p2.name ? 'p1' : 'p2' : p1s.stats.atk > p2s.stats.atk ? 'p1' : 'p2';\n  for (let turn = 1; turn <= MAX_TURNS; turn++) {\n    if (p1s.hp <= 0 || p2s.hp <= 0) break;\n\n    // Each turn (0.5s), each side chooses one action: fast, charged (if enough energy), or do nothing.\n    const a1 = chooseAction(p1s, p2s);\n    const a2 = chooseAction(p2s, p1s);\n\n    // Resolve actions. Charged moves go before fast moves; if both charged, CMP decides order.\n    const order = resolveOrder(a1, a2, cmpFirst);\n    for (const actor of order) {\n      if (p1s.hp <= 0 || p2s.hp <= 0) break;\n      const me = actor === 'p1' ? p1s : p2s;\n      const opp = actor === 'p1' ? p2s : p1s;\n      if (me.pending.action === 'charged') {\n        // Shield check\n        const willShield = opp.shields > 0; // Simple neutral heuristic; swap with your UI choice or smarter logic\n        const dmg = chargedDamage(me, opp);\n        if (willShield) {\n          opp.shields -= 1;\n          // Debuffs/buffs still apply even if shielded\n          applyBuffs(me, opp, me.pending.move);\n        } else {\n          opp.hp -= dmg;\n          applyBuffs(me, opp, me.pending.move);\n        }\n        me.energy -= me.pending.move.energyCost;\n        me.pending = null;\n      } else if (me.pending.action === 'fast') {\n        // Apply fast move damage immediately at end of its durationTurn window (we assume it �lands� each turn for simplicity)\n        const dmg = fastDamage(me, opp);\n        opp.hp -= dmg;\n        me.energy = clamp(me.energy + me.fast.energyGain, 0, 100);\n        me.fastTurnsLeft -= 1;\n        if (me.fastTurnsLeft <= 0) {\n          me.pending = null; // ready for next selection next turn\n          me.fastTurnsLeft = me.fast.durationTurns;\n        }\n      }\n    }\n\n    // End condition\n    if (p1s.hp <= 0 || p2s.hp <= 0) break;\n\n    // If no one queued an action, auto-queue fast moves for next turn\n    if (!p1s.pending) startFast(p1s);\n    if (!p2s.pending) startFast(p2s);\n  }\n  const result = p1s.hp <= 0 && p2s.hp <= 0 ? 'draw' : p2s.hp <= 0 ? 'p1' : p1s.hp <= 0 ? 'p2' : 'timeout';\n  return {\n    result,\n    p1: {\n      hp: Math.max(0, Math.ceil(p1s.hp)),\n      shields: p1s.shields,\n      energy: Math.round(p1s.energy)\n    },\n    p2: {\n      hp: Math.max(0, Math.ceil(p2s.hp)),\n      shields: p2s.shields,\n      energy: Math.round(p2s.energy)\n    }\n  };\n}\n\n/* ===================== Internal pieces ===================== */\n\nfunction initSide(p) {\n  var _p$shields;\n  const stats = trueStats(p.base, p.iv, p.level, !!p.isShadow);\n  const side = {\n    name: p.name,\n    types: p.types,\n    stats,\n    atkStages: 0,\n    defStages: 0,\n    hp: stats.hp,\n    energy: 0,\n    shields: (_p$shields = p.shields) !== null && _p$shields !== void 0 ? _p$shields : 2,\n    fast: {\n      type: p.fastMove.type,\n      power: p.fastMove.power,\n      energyGain: p.fastMove.energyGain,\n      durationTurns: p.fastMove.durationTurns\n    },\n    charged: p.chargedMoves.map(m => ({\n      ...m\n    })),\n    pending: null,\n    fastTurnsLeft: p.fastMove.durationTurns\n  };\n  // Start with a fast move queued\n  startFast(side);\n  return side;\n}\nfunction startFast(me) {\n  me.pending = {\n    action: 'fast',\n    move: me.fast\n  };\n  // fastTurnsLeft already set\n}\nfunction chooseAction(me, opp) {\n  // Simple, deterministic policy:\n  // If any charged move is available, use the highest �effective damage� move; else continue fast.\n  const ready = me.charged.filter(m => me.energy >= m.energyCost);\n  if (ready.length) {\n    const scored = ready.map(m => {\n      const stab = stabMultiplier(m.type, me.types);\n      const eff = typeEffectiveness(m.type, opp.types);\n      const stageMult = stagePairMultiplier(me.atkStages, opp.defStages);\n      const dmg = pvpDamage(m.power, me.stats.atk, opp.stats.def, stab, eff, stageMult);\n      // Prefer higher damage; very light preference for cheaper cost to avoid overcapping\n      const score = dmg + (100 - m.energyCost) * 0.05;\n      return {\n        m,\n        score\n      };\n    }).sort((a, b) => b.score - a.score);\n    me.pending = {\n      action: 'charged',\n      move: scored[0].m\n    };\n  } else {\n    if (!me.pending) startFast(me);\n  }\n  return me.pending;\n}\nfunction resolveOrder(a1, a2, cmpFirst) {\n  if (a1 && a1.action === 'charged' && a2 && a2.action === 'charged') {\n    return cmpFirst === 'p1' ? ['p1', 'p2'] : ['p2', 'p1'];\n  }\n  if (a1 && a1.action === 'charged') return ['p1', 'p2'];\n  if (a2 && a2.action === 'charged') return ['p2', 'p1'];\n  // Both fast or idle -> simultaneous; resolve as p1 then p2 (order doesn�t matter for symmetric fast exchange)\n  return ['p1', 'p2'];\n}\nfunction fastDamage(me, opp) {\n  const stab = stabMultiplier(me.fast.type, me.types);\n  const eff = typeEffectiveness(me.fast.type, opp.types);\n  const stageMult = stagePairMultiplier(me.atkStages, opp.defStages);\n  return pvpDamage(me.fast.power, me.stats.atk, opp.stats.def, stab, eff, stageMult);\n}\nfunction chargedDamage(me, opp) {\n  const move = me.pending.move;\n  const stab = stabMultiplier(move.type, me.types);\n  const eff = typeEffectiveness(move.type, opp.types);\n  const stageMult = stagePairMultiplier(me.atkStages, opp.defStages);\n  return pvpDamage(move.power, me.stats.atk, opp.stats.def, stab, eff, stageMult);\n}\nfunction applyBuffs(me, opp, move) {\n  var _move$buff$applyChanc, _move$buff$atkDelta, _move$buff$defDelta;\n  if (!move.buff) return;\n  const chance = (_move$buff$applyChanc = move.buff.applyChance) !== null && _move$buff$applyChanc !== void 0 ? _move$buff$applyChanc : 1.0;\n  if (chance < 1) {\n    // Deterministic path: treat fractional chance as expected value spread across turns (optional).\n    // For now, only apply when chance === 1.0 to keep �who wins� deterministic.\n    if (chance !== 1) return;\n  }\n  const deltaAtk = (_move$buff$atkDelta = move.buff.atkDelta) !== null && _move$buff$atkDelta !== void 0 ? _move$buff$atkDelta : 0;\n  const deltaDef = (_move$buff$defDelta = move.buff.defDelta) !== null && _move$buff$defDelta !== void 0 ? _move$buff$defDelta : 0;\n  if (move.buff.target === 'self') {\n    me.atkStages = clamp(me.atkStages + deltaAtk, -4, 4);\n    me.defStages = clamp(me.defStages + deltaDef, -4, 4);\n  } else {\n    opp.atkStages = clamp(opp.atkStages + deltaAtk, -4, 4);\n    opp.defStages = clamp(opp.defStages + deltaDef, -4, 4);\n  }\n}","map":{"version":3,"names":["CPM","typeChart","normal","rock","ghost","steel","fire","water","grass","ice","bug","dragon","ground","clamp","v","min","max","Math","stabMultiplier","moveType","monTypes","includes","typeEffectiveness","defenderTypes","mult","t","_row$t","row","trueStats","base","iv","level","isShadow","cpm","String","Error","atkMult","defMult","atk","def","hp","floor","pvpDamage","power","stab","eff","stageMult","raw","STAGE_MULT","stageIndexFromDelta","delta","stagePairMultiplier","atkStages","defStages","a","d","simulateBattle","p1","p2","opts","_opts$maxTurns","MAX_TURNS","maxTurns","p1s","initSide","p2s","cmpFirst","stats","name","turn","a1","chooseAction","a2","order","resolveOrder","actor","me","opp","pending","action","willShield","shields","dmg","chargedDamage","applyBuffs","move","energy","energyCost","fastDamage","fast","energyGain","fastTurnsLeft","durationTurns","startFast","result","ceil","round","p","_p$shields","side","types","type","fastMove","charged","chargedMoves","map","m","ready","filter","length","scored","score","sort","b","_move$buff$applyChanc","_move$buff$atkDelta","_move$buff$defDelta","buff","chance","applyChance","deltaAtk","atkDelta","deltaDef","defDelta","target"],"sources":["C:/Users/ben/Projects/nebsojipvptrainer/src/engine/battleEngine.js"],"sourcesContent":["// src/engine/battleEngine.js\r\n// Minimal, accurate PvP simulator core for �who wins�\r\n// Assumes you pass in Pokemon + moves sourced from a PvP-ready gamemaster (PvPoke format is ideal).\r\n\r\n/* ===================== Data plumbing ===================== */\r\n\r\n// CPM table (levels 1.0 ... 51.0 in 0.5 steps). Truncated here; include full table you already use.\r\nexport const CPM = {\r\n  \"40\": 0.79030001, \"41\": 0.79530001, \"50\": 0.84029999, \"51\": 0.84529999\r\n  // <-- Replace with your full CPM table for all supported levels\r\n};\r\n\r\n// Simple type chart (multiplier). Fill with full chart in your project.\r\n// Example: typeChart['ground']['electric'] === 1.6, typeChart['electric']['ground'] === 0.625, etc.\r\nexport const typeChart = {\r\n  normal: { rock: 0.625, ghost: 0.390625, steel: 0.625 },\r\n  fire:   { fire: 0.625, water: 0.625, grass: 1.6, ice: 1.6, bug: 1.6, rock: 0.625, dragon: 0.625, steel: 1.6 },\r\n  water:  { fire: 1.6, water: 0.625, grass: 0.625, ground: 1.6, rock: 1.6, dragon: 0.625 },\r\n  // ... complete all 18 types\r\n};\r\n\r\n/* ===================== Helpers ===================== */\r\n\r\nfunction clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }\r\n\r\nfunction stabMultiplier(moveType, monTypes) {\r\n  return monTypes.includes(moveType) ? 1.2 : 1.0; // STAB\r\n}\r\n\r\nfunction typeEffectiveness(moveType, defenderTypes) {\r\n  let mult = 1.0;\r\n  for (const t of defenderTypes) {\r\n    const row = typeChart[moveType] || {};\r\n    mult *= (row[t] ?? 1.0);\r\n  }\r\n  return mult;\r\n}\r\n\r\nexport function trueStats(base, iv, level, isShadow=false) {\r\n  // Attack/Defense/HP for PvP\r\n  const cpm = CPM[String(level)];\r\n  if (!cpm) throw new Error(`Missing CPM for level ${level}`);\r\n  // Shadow: Atk *1.2, Def *0.833333... (approx), modeled as per Niantic; tweak if your dataset encodes it differently.\r\n  const atkMult = isShadow ? 1.2 : 1.0;\r\n  const defMult = isShadow ? (5/6) : 1.0;\r\n\r\n  const atk = (base.atk + iv.atk) * cpm * atkMult;\r\n  const def = (base.def + iv.def) * cpm * defMult;\r\n  const hp  = Math.floor((base.hp  + iv.hp ) * cpm);\r\n  return { atk, def, hp: Math.max(1, hp) };\r\n}\r\n\r\nexport function pvpDamage(power, atk, def, stab, eff, stageMult=1.0) {\r\n  // Floor(0.5 * Power * (Atk/Def) * STAB * Effectiveness * stageMult) + 1\r\n  // stageMult is the combined buff/debuff multiplier (attack vs defense stages)\r\n  const raw = 0.5 * power * (atk/def) * stab * eff * stageMult;\r\n  return Math.floor(raw) + 1;\r\n}\r\n\r\n// Convert stages to multipliers (each stage ~10% in PvP; Niantic uses hidden multipliers)\r\n// Commonly modeled as: stage: -4..+4 -> multipliers [see PvPoke]. Here�s a typical table:\r\nconst STAGE_MULT = [0.5, 0.571, 0.667, 0.8, 1.0, 1.25, 1.5, 1.75, 2.0]; // index 0..8 maps to -4..+4\r\nfunction stageIndexFromDelta(delta) { return clamp(delta + 4, 0, 8); }\r\nfunction stagePairMultiplier(atkStages, defStages) {\r\n  const a = STAGE_MULT[stageIndexFromDelta(atkStages)];\r\n  const d = STAGE_MULT[stageIndexFromDelta(defStages)];\r\n  return a / d;\r\n}\r\n\r\n/* ===================== Core simulator ===================== */\r\n\r\n/**\r\n * move objects expected shape (PvP values):\r\n * fastMove: { id, type, power, energyGain, durationTurns }\r\n * chargedMoves: [{ id, type, power, energyCost, buff?: { target:\"self\"|\"opponent\", atkDelta?:number, defDelta?:number, applyChance?:number } }]\r\n */\r\nexport function simulateBattle(p1, p2, opts = {}) {\r\n  // p1/p2: { name, types:[t1,t2?], base:{atk,def,hp}, iv:{atk,def,hp}, level, isShadow, fastMove, chargedMoves:[...], shields }\r\n  const MAX_TURNS = opts.maxTurns ?? 1000; // 1000 turns = 500s > 240s hard clock, fine for result\r\n  const p1s = initSide(p1);\r\n  const p2s = initSide(p2);\r\n\r\n  // CMP: true Attack decides who throws first when both use a charged move on the same turn\r\n  const cmpFirst = p1s.stats.atk === p2s.stats.atk ? (p1.name <= p2.name ? 'p1' : 'p2') :\r\n                   (p1s.stats.atk > p2s.stats.atk ? 'p1' : 'p2');\r\n\r\n  for (let turn = 1; turn <= MAX_TURNS; turn++) {\r\n    if (p1s.hp <= 0 || p2s.hp <= 0) break;\r\n\r\n    // Each turn (0.5s), each side chooses one action: fast, charged (if enough energy), or do nothing.\r\n    const a1 = chooseAction(p1s, p2s);\r\n    const a2 = chooseAction(p2s, p1s);\r\n\r\n    // Resolve actions. Charged moves go before fast moves; if both charged, CMP decides order.\r\n    const order = resolveOrder(a1, a2, cmpFirst);\r\n\r\n    for (const actor of order) {\r\n      if (p1s.hp <= 0 || p2s.hp <= 0) break;\r\n      const me = actor === 'p1' ? p1s : p2s;\r\n      const opp = actor === 'p1' ? p2s : p1s;\r\n\r\n      if (me.pending.action === 'charged') {\r\n        // Shield check\r\n        const willShield = opp.shields > 0; // Simple neutral heuristic; swap with your UI choice or smarter logic\r\n        const dmg = chargedDamage(me, opp);\r\n\r\n        if (willShield) {\r\n          opp.shields -= 1;\r\n          // Debuffs/buffs still apply even if shielded\r\n          applyBuffs(me, opp, me.pending.move);\r\n        } else {\r\n          opp.hp -= dmg;\r\n          applyBuffs(me, opp, me.pending.move);\r\n        }\r\n        me.energy -= me.pending.move.energyCost;\r\n        me.pending = null;\r\n\r\n      } else if (me.pending.action === 'fast') {\r\n        // Apply fast move damage immediately at end of its durationTurn window (we assume it �lands� each turn for simplicity)\r\n        const dmg = fastDamage(me, opp);\r\n        opp.hp -= dmg;\r\n        me.energy = clamp(me.energy + me.fast.energyGain, 0, 100);\r\n        me.fastTurnsLeft -= 1;\r\n        if (me.fastTurnsLeft <= 0) {\r\n          me.pending = null; // ready for next selection next turn\r\n          me.fastTurnsLeft = me.fast.durationTurns;\r\n        }\r\n      }\r\n    }\r\n\r\n    // End condition\r\n    if (p1s.hp <= 0 || p2s.hp <= 0) break;\r\n\r\n    // If no one queued an action, auto-queue fast moves for next turn\r\n    if (!p1s.pending) startFast(p1s);\r\n    if (!p2s.pending) startFast(p2s);\r\n  }\r\n\r\n  const result =\r\n    p1s.hp <= 0 && p2s.hp <= 0 ? 'draw' :\r\n    p2s.hp <= 0 ? 'p1' :\r\n    p1s.hp <= 0 ? 'p2' : 'timeout';\r\n\r\n  return {\r\n    result,\r\n    p1: { hp: Math.max(0, Math.ceil(p1s.hp)), shields: p1s.shields, energy: Math.round(p1s.energy) },\r\n    p2: { hp: Math.max(0, Math.ceil(p2s.hp)), shields: p2s.shields, energy: Math.round(p2s.energy) }\r\n  };\r\n}\r\n\r\n/* ===================== Internal pieces ===================== */\r\n\r\nfunction initSide(p) {\r\n  const stats = trueStats(p.base, p.iv, p.level, !!p.isShadow);\r\n  const side = {\r\n    name: p.name,\r\n    types: p.types,\r\n    stats,\r\n    atkStages: 0,\r\n    defStages: 0,\r\n    hp: stats.hp,\r\n    energy: 0,\r\n    shields: p.shields ?? 2,\r\n    fast: {\r\n      type: p.fastMove.type,\r\n      power: p.fastMove.power,\r\n      energyGain: p.fastMove.energyGain,\r\n      durationTurns: p.fastMove.durationTurns\r\n    },\r\n    charged: p.chargedMoves.map(m => ({ ...m })),\r\n    pending: null,\r\n    fastTurnsLeft: p.fastMove.durationTurns\r\n  };\r\n  // Start with a fast move queued\r\n  startFast(side);\r\n  return side;\r\n}\r\n\r\nfunction startFast(me) {\r\n  me.pending = { action: 'fast', move: me.fast };\r\n  // fastTurnsLeft already set\r\n}\r\n\r\nfunction chooseAction(me, opp) {\r\n  // Simple, deterministic policy:\r\n  // If any charged move is available, use the highest �effective damage� move; else continue fast.\r\n  const ready = me.charged.filter(m => me.energy >= m.energyCost);\r\n  if (ready.length) {\r\n    const scored = ready.map(m => {\r\n      const stab = stabMultiplier(m.type, me.types);\r\n      const eff  = typeEffectiveness(m.type, opp.types);\r\n      const stageMult = stagePairMultiplier(me.atkStages, opp.defStages);\r\n      const dmg = pvpDamage(m.power, me.stats.atk, opp.stats.def, stab, eff, stageMult);\r\n      // Prefer higher damage; very light preference for cheaper cost to avoid overcapping\r\n      const score = dmg + (100 - m.energyCost) * 0.05;\r\n      return { m, score };\r\n    }).sort((a, b) => b.score - a.score);\r\n    me.pending = { action: 'charged', move: scored[0].m };\r\n  } else {\r\n    if (!me.pending) startFast(me);\r\n  }\r\n  return me.pending;\r\n}\r\n\r\nfunction resolveOrder(a1, a2, cmpFirst) {\r\n  if (a1 && a1.action === 'charged' && a2 && a2.action === 'charged') {\r\n    return cmpFirst === 'p1' ? ['p1','p2'] : ['p2','p1'];\r\n  }\r\n  if (a1 && a1.action === 'charged') return ['p1','p2'];\r\n  if (a2 && a2.action === 'charged') return ['p2','p1'];\r\n  // Both fast or idle -> simultaneous; resolve as p1 then p2 (order doesn�t matter for symmetric fast exchange)\r\n  return ['p1','p2'];\r\n}\r\n\r\nfunction fastDamage(me, opp) {\r\n  const stab = stabMultiplier(me.fast.type, me.types);\r\n  const eff  = typeEffectiveness(me.fast.type, opp.types);\r\n  const stageMult = stagePairMultiplier(me.atkStages, opp.defStages);\r\n  return pvpDamage(me.fast.power, me.stats.atk, opp.stats.def, stab, eff, stageMult);\r\n}\r\n\r\nfunction chargedDamage(me, opp) {\r\n  const move = me.pending.move;\r\n  const stab = stabMultiplier(move.type, me.types);\r\n  const eff  = typeEffectiveness(move.type, opp.types);\r\n  const stageMult = stagePairMultiplier(me.atkStages, opp.defStages);\r\n  return pvpDamage(move.power, me.stats.atk, opp.stats.def, stab, eff, stageMult);\r\n}\r\n\r\nfunction applyBuffs(me, opp, move) {\r\n  if (!move.buff) return;\r\n  const chance = move.buff.applyChance ?? 1.0;\r\n  if (chance < 1) {\r\n    // Deterministic path: treat fractional chance as expected value spread across turns (optional).\r\n    // For now, only apply when chance === 1.0 to keep �who wins� deterministic.\r\n    if (chance !== 1) return;\r\n  }\r\n  const deltaAtk = move.buff.atkDelta ?? 0;\r\n  const deltaDef = move.buff.defDelta ?? 0;\r\n  if (move.buff.target === 'self') {\r\n    me.atkStages = clamp(me.atkStages + deltaAtk, -4, 4);\r\n    me.defStages = clamp(me.defStages + deltaDef, -4, 4);\r\n  } else {\r\n    opp.atkStages = clamp(opp.atkStages + deltaAtk, -4, 4);\r\n    opp.defStages = clamp(opp.defStages + deltaDef, -4, 4);\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;;AAEA;;AAEA;AACA,OAAO,MAAMA,GAAG,GAAG;EACjB,IAAI,EAAE,UAAU;EAAE,IAAI,EAAE,UAAU;EAAE,IAAI,EAAE,UAAU;EAAE,IAAI,EAAE;EAC5D;AACF,CAAC;;AAED;AACA;AACA,OAAO,MAAMC,SAAS,GAAG;EACvBC,MAAM,EAAE;IAAEC,IAAI,EAAE,KAAK;IAAEC,KAAK,EAAE,QAAQ;IAAEC,KAAK,EAAE;EAAM,CAAC;EACtDC,IAAI,EAAI;IAAEA,IAAI,EAAE,KAAK;IAAEC,KAAK,EAAE,KAAK;IAAEC,KAAK,EAAE,GAAG;IAAEC,GAAG,EAAE,GAAG;IAAEC,GAAG,EAAE,GAAG;IAAEP,IAAI,EAAE,KAAK;IAAEQ,MAAM,EAAE,KAAK;IAAEN,KAAK,EAAE;EAAI,CAAC;EAC7GE,KAAK,EAAG;IAAED,IAAI,EAAE,GAAG;IAAEC,KAAK,EAAE,KAAK;IAAEC,KAAK,EAAE,KAAK;IAAEI,MAAM,EAAE,GAAG;IAAET,IAAI,EAAE,GAAG;IAAEQ,MAAM,EAAE;EAAM;EACvF;AACF,CAAC;;AAED;;AAEA,SAASE,KAAKA,CAACC,CAAC,EAAEC,GAAG,EAAEC,GAAG,EAAE;EAAE,OAAOC,IAAI,CAACD,GAAG,CAACD,GAAG,EAAEE,IAAI,CAACF,GAAG,CAACC,GAAG,EAAEF,CAAC,CAAC,CAAC;AAAE;AAEtE,SAASI,cAAcA,CAACC,QAAQ,EAAEC,QAAQ,EAAE;EAC1C,OAAOA,QAAQ,CAACC,QAAQ,CAACF,QAAQ,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;AAClD;AAEA,SAASG,iBAAiBA,CAACH,QAAQ,EAAEI,aAAa,EAAE;EAClD,IAAIC,IAAI,GAAG,GAAG;EACd,KAAK,MAAMC,CAAC,IAAIF,aAAa,EAAE;IAAA,IAAAG,MAAA;IAC7B,MAAMC,GAAG,GAAG1B,SAAS,CAACkB,QAAQ,CAAC,IAAI,CAAC,CAAC;IACrCK,IAAI,KAAAE,MAAA,GAAKC,GAAG,CAACF,CAAC,CAAC,cAAAC,MAAA,cAAAA,MAAA,GAAI,GAAI;EACzB;EACA,OAAOF,IAAI;AACb;AAEA,OAAO,SAASI,SAASA,CAACC,IAAI,EAAEC,EAAE,EAAEC,KAAK,EAAEC,QAAQ,GAAC,KAAK,EAAE;EACzD;EACA,MAAMC,GAAG,GAAGjC,GAAG,CAACkC,MAAM,CAACH,KAAK,CAAC,CAAC;EAC9B,IAAI,CAACE,GAAG,EAAE,MAAM,IAAIE,KAAK,CAAC,yBAAyBJ,KAAK,EAAE,CAAC;EAC3D;EACA,MAAMK,OAAO,GAAGJ,QAAQ,GAAG,GAAG,GAAG,GAAG;EACpC,MAAMK,OAAO,GAAGL,QAAQ,GAAI,CAAC,GAAC,CAAC,GAAI,GAAG;EAEtC,MAAMM,GAAG,GAAG,CAACT,IAAI,CAACS,GAAG,GAAGR,EAAE,CAACQ,GAAG,IAAIL,GAAG,GAAGG,OAAO;EAC/C,MAAMG,GAAG,GAAG,CAACV,IAAI,CAACU,GAAG,GAAGT,EAAE,CAACS,GAAG,IAAIN,GAAG,GAAGI,OAAO;EAC/C,MAAMG,EAAE,GAAIvB,IAAI,CAACwB,KAAK,CAAC,CAACZ,IAAI,CAACW,EAAE,GAAIV,EAAE,CAACU,EAAE,IAAKP,GAAG,CAAC;EACjD,OAAO;IAAEK,GAAG;IAAEC,GAAG;IAAEC,EAAE,EAAEvB,IAAI,CAACD,GAAG,CAAC,CAAC,EAAEwB,EAAE;EAAE,CAAC;AAC1C;AAEA,OAAO,SAASE,SAASA,CAACC,KAAK,EAAEL,GAAG,EAAEC,GAAG,EAAEK,IAAI,EAAEC,GAAG,EAAEC,SAAS,GAAC,GAAG,EAAE;EACnE;EACA;EACA,MAAMC,GAAG,GAAG,GAAG,GAAGJ,KAAK,IAAIL,GAAG,GAACC,GAAG,CAAC,GAAGK,IAAI,GAAGC,GAAG,GAAGC,SAAS;EAC5D,OAAO7B,IAAI,CAACwB,KAAK,CAACM,GAAG,CAAC,GAAG,CAAC;AAC5B;;AAEA;AACA;AACA,MAAMC,UAAU,GAAG,CAAC,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC;AACxE,SAASC,mBAAmBA,CAACC,KAAK,EAAE;EAAE,OAAOrC,KAAK,CAACqC,KAAK,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAAE;AACrE,SAASC,mBAAmBA,CAACC,SAAS,EAAEC,SAAS,EAAE;EACjD,MAAMC,CAAC,GAAGN,UAAU,CAACC,mBAAmB,CAACG,SAAS,CAAC,CAAC;EACpD,MAAMG,CAAC,GAAGP,UAAU,CAACC,mBAAmB,CAACI,SAAS,CAAC,CAAC;EACpD,OAAOC,CAAC,GAAGC,CAAC;AACd;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,cAAcA,CAACC,EAAE,EAAEC,EAAE,EAAEC,IAAI,GAAG,CAAC,CAAC,EAAE;EAAA,IAAAC,cAAA;EAChD;EACA,MAAMC,SAAS,IAAAD,cAAA,GAAGD,IAAI,CAACG,QAAQ,cAAAF,cAAA,cAAAA,cAAA,GAAI,IAAI,CAAC,CAAC;EACzC,MAAMG,GAAG,GAAGC,QAAQ,CAACP,EAAE,CAAC;EACxB,MAAMQ,GAAG,GAAGD,QAAQ,CAACN,EAAE,CAAC;;EAExB;EACA,MAAMQ,QAAQ,GAAGH,GAAG,CAACI,KAAK,CAAC7B,GAAG,KAAK2B,GAAG,CAACE,KAAK,CAAC7B,GAAG,GAAImB,EAAE,CAACW,IAAI,IAAIV,EAAE,CAACU,IAAI,GAAG,IAAI,GAAG,IAAI,GAClEL,GAAG,CAACI,KAAK,CAAC7B,GAAG,GAAG2B,GAAG,CAACE,KAAK,CAAC7B,GAAG,GAAG,IAAI,GAAG,IAAK;EAE9D,KAAK,IAAI+B,IAAI,GAAG,CAAC,EAAEA,IAAI,IAAIR,SAAS,EAAEQ,IAAI,EAAE,EAAE;IAC5C,IAAIN,GAAG,CAACvB,EAAE,IAAI,CAAC,IAAIyB,GAAG,CAACzB,EAAE,IAAI,CAAC,EAAE;;IAEhC;IACA,MAAM8B,EAAE,GAAGC,YAAY,CAACR,GAAG,EAAEE,GAAG,CAAC;IACjC,MAAMO,EAAE,GAAGD,YAAY,CAACN,GAAG,EAAEF,GAAG,CAAC;;IAEjC;IACA,MAAMU,KAAK,GAAGC,YAAY,CAACJ,EAAE,EAAEE,EAAE,EAAEN,QAAQ,CAAC;IAE5C,KAAK,MAAMS,KAAK,IAAIF,KAAK,EAAE;MACzB,IAAIV,GAAG,CAACvB,EAAE,IAAI,CAAC,IAAIyB,GAAG,CAACzB,EAAE,IAAI,CAAC,EAAE;MAChC,MAAMoC,EAAE,GAAGD,KAAK,KAAK,IAAI,GAAGZ,GAAG,GAAGE,GAAG;MACrC,MAAMY,GAAG,GAAGF,KAAK,KAAK,IAAI,GAAGV,GAAG,GAAGF,GAAG;MAEtC,IAAIa,EAAE,CAACE,OAAO,CAACC,MAAM,KAAK,SAAS,EAAE;QACnC;QACA,MAAMC,UAAU,GAAGH,GAAG,CAACI,OAAO,GAAG,CAAC,CAAC,CAAC;QACpC,MAAMC,GAAG,GAAGC,aAAa,CAACP,EAAE,EAAEC,GAAG,CAAC;QAElC,IAAIG,UAAU,EAAE;UACdH,GAAG,CAACI,OAAO,IAAI,CAAC;UAChB;UACAG,UAAU,CAACR,EAAE,EAAEC,GAAG,EAAED,EAAE,CAACE,OAAO,CAACO,IAAI,CAAC;QACtC,CAAC,MAAM;UACLR,GAAG,CAACrC,EAAE,IAAI0C,GAAG;UACbE,UAAU,CAACR,EAAE,EAAEC,GAAG,EAAED,EAAE,CAACE,OAAO,CAACO,IAAI,CAAC;QACtC;QACAT,EAAE,CAACU,MAAM,IAAIV,EAAE,CAACE,OAAO,CAACO,IAAI,CAACE,UAAU;QACvCX,EAAE,CAACE,OAAO,GAAG,IAAI;MAEnB,CAAC,MAAM,IAAIF,EAAE,CAACE,OAAO,CAACC,MAAM,KAAK,MAAM,EAAE;QACvC;QACA,MAAMG,GAAG,GAAGM,UAAU,CAACZ,EAAE,EAAEC,GAAG,CAAC;QAC/BA,GAAG,CAACrC,EAAE,IAAI0C,GAAG;QACbN,EAAE,CAACU,MAAM,GAAGzE,KAAK,CAAC+D,EAAE,CAACU,MAAM,GAAGV,EAAE,CAACa,IAAI,CAACC,UAAU,EAAE,CAAC,EAAE,GAAG,CAAC;QACzDd,EAAE,CAACe,aAAa,IAAI,CAAC;QACrB,IAAIf,EAAE,CAACe,aAAa,IAAI,CAAC,EAAE;UACzBf,EAAE,CAACE,OAAO,GAAG,IAAI,CAAC,CAAC;UACnBF,EAAE,CAACe,aAAa,GAAGf,EAAE,CAACa,IAAI,CAACG,aAAa;QAC1C;MACF;IACF;;IAEA;IACA,IAAI7B,GAAG,CAACvB,EAAE,IAAI,CAAC,IAAIyB,GAAG,CAACzB,EAAE,IAAI,CAAC,EAAE;;IAEhC;IACA,IAAI,CAACuB,GAAG,CAACe,OAAO,EAAEe,SAAS,CAAC9B,GAAG,CAAC;IAChC,IAAI,CAACE,GAAG,CAACa,OAAO,EAAEe,SAAS,CAAC5B,GAAG,CAAC;EAClC;EAEA,MAAM6B,MAAM,GACV/B,GAAG,CAACvB,EAAE,IAAI,CAAC,IAAIyB,GAAG,CAACzB,EAAE,IAAI,CAAC,GAAG,MAAM,GACnCyB,GAAG,CAACzB,EAAE,IAAI,CAAC,GAAG,IAAI,GAClBuB,GAAG,CAACvB,EAAE,IAAI,CAAC,GAAG,IAAI,GAAG,SAAS;EAEhC,OAAO;IACLsD,MAAM;IACNrC,EAAE,EAAE;MAAEjB,EAAE,EAAEvB,IAAI,CAACD,GAAG,CAAC,CAAC,EAAEC,IAAI,CAAC8E,IAAI,CAAChC,GAAG,CAACvB,EAAE,CAAC,CAAC;MAAEyC,OAAO,EAAElB,GAAG,CAACkB,OAAO;MAAEK,MAAM,EAAErE,IAAI,CAAC+E,KAAK,CAACjC,GAAG,CAACuB,MAAM;IAAE,CAAC;IAChG5B,EAAE,EAAE;MAAElB,EAAE,EAAEvB,IAAI,CAACD,GAAG,CAAC,CAAC,EAAEC,IAAI,CAAC8E,IAAI,CAAC9B,GAAG,CAACzB,EAAE,CAAC,CAAC;MAAEyC,OAAO,EAAEhB,GAAG,CAACgB,OAAO;MAAEK,MAAM,EAAErE,IAAI,CAAC+E,KAAK,CAAC/B,GAAG,CAACqB,MAAM;IAAE;EACjG,CAAC;AACH;;AAEA;;AAEA,SAAStB,QAAQA,CAACiC,CAAC,EAAE;EAAA,IAAAC,UAAA;EACnB,MAAM/B,KAAK,GAAGvC,SAAS,CAACqE,CAAC,CAACpE,IAAI,EAAEoE,CAAC,CAACnE,EAAE,EAAEmE,CAAC,CAAClE,KAAK,EAAE,CAAC,CAACkE,CAAC,CAACjE,QAAQ,CAAC;EAC5D,MAAMmE,IAAI,GAAG;IACX/B,IAAI,EAAE6B,CAAC,CAAC7B,IAAI;IACZgC,KAAK,EAAEH,CAAC,CAACG,KAAK;IACdjC,KAAK;IACLf,SAAS,EAAE,CAAC;IACZC,SAAS,EAAE,CAAC;IACZb,EAAE,EAAE2B,KAAK,CAAC3B,EAAE;IACZ8C,MAAM,EAAE,CAAC;IACTL,OAAO,GAAAiB,UAAA,GAAED,CAAC,CAAChB,OAAO,cAAAiB,UAAA,cAAAA,UAAA,GAAI,CAAC;IACvBT,IAAI,EAAE;MACJY,IAAI,EAAEJ,CAAC,CAACK,QAAQ,CAACD,IAAI;MACrB1D,KAAK,EAAEsD,CAAC,CAACK,QAAQ,CAAC3D,KAAK;MACvB+C,UAAU,EAAEO,CAAC,CAACK,QAAQ,CAACZ,UAAU;MACjCE,aAAa,EAAEK,CAAC,CAACK,QAAQ,CAACV;IAC5B,CAAC;IACDW,OAAO,EAAEN,CAAC,CAACO,YAAY,CAACC,GAAG,CAACC,CAAC,KAAK;MAAE,GAAGA;IAAE,CAAC,CAAC,CAAC;IAC5C5B,OAAO,EAAE,IAAI;IACba,aAAa,EAAEM,CAAC,CAACK,QAAQ,CAACV;EAC5B,CAAC;EACD;EACAC,SAAS,CAACM,IAAI,CAAC;EACf,OAAOA,IAAI;AACb;AAEA,SAASN,SAASA,CAACjB,EAAE,EAAE;EACrBA,EAAE,CAACE,OAAO,GAAG;IAAEC,MAAM,EAAE,MAAM;IAAEM,IAAI,EAAET,EAAE,CAACa;EAAK,CAAC;EAC9C;AACF;AAEA,SAASlB,YAAYA,CAACK,EAAE,EAAEC,GAAG,EAAE;EAC7B;EACA;EACA,MAAM8B,KAAK,GAAG/B,EAAE,CAAC2B,OAAO,CAACK,MAAM,CAACF,CAAC,IAAI9B,EAAE,CAACU,MAAM,IAAIoB,CAAC,CAACnB,UAAU,CAAC;EAC/D,IAAIoB,KAAK,CAACE,MAAM,EAAE;IAChB,MAAMC,MAAM,GAAGH,KAAK,CAACF,GAAG,CAACC,CAAC,IAAI;MAC5B,MAAM9D,IAAI,GAAG1B,cAAc,CAACwF,CAAC,CAACL,IAAI,EAAEzB,EAAE,CAACwB,KAAK,CAAC;MAC7C,MAAMvD,GAAG,GAAIvB,iBAAiB,CAACoF,CAAC,CAACL,IAAI,EAAExB,GAAG,CAACuB,KAAK,CAAC;MACjD,MAAMtD,SAAS,GAAGK,mBAAmB,CAACyB,EAAE,CAACxB,SAAS,EAAEyB,GAAG,CAACxB,SAAS,CAAC;MAClE,MAAM6B,GAAG,GAAGxC,SAAS,CAACgE,CAAC,CAAC/D,KAAK,EAAEiC,EAAE,CAACT,KAAK,CAAC7B,GAAG,EAAEuC,GAAG,CAACV,KAAK,CAAC5B,GAAG,EAAEK,IAAI,EAAEC,GAAG,EAAEC,SAAS,CAAC;MACjF;MACA,MAAMiE,KAAK,GAAG7B,GAAG,GAAG,CAAC,GAAG,GAAGwB,CAAC,CAACnB,UAAU,IAAI,IAAI;MAC/C,OAAO;QAAEmB,CAAC;QAAEK;MAAM,CAAC;IACrB,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC1D,CAAC,EAAE2D,CAAC,KAAKA,CAAC,CAACF,KAAK,GAAGzD,CAAC,CAACyD,KAAK,CAAC;IACpCnC,EAAE,CAACE,OAAO,GAAG;MAAEC,MAAM,EAAE,SAAS;MAAEM,IAAI,EAAEyB,MAAM,CAAC,CAAC,CAAC,CAACJ;IAAE,CAAC;EACvD,CAAC,MAAM;IACL,IAAI,CAAC9B,EAAE,CAACE,OAAO,EAAEe,SAAS,CAACjB,EAAE,CAAC;EAChC;EACA,OAAOA,EAAE,CAACE,OAAO;AACnB;AAEA,SAASJ,YAAYA,CAACJ,EAAE,EAAEE,EAAE,EAAEN,QAAQ,EAAE;EACtC,IAAII,EAAE,IAAIA,EAAE,CAACS,MAAM,KAAK,SAAS,IAAIP,EAAE,IAAIA,EAAE,CAACO,MAAM,KAAK,SAAS,EAAE;IAClE,OAAOb,QAAQ,KAAK,IAAI,GAAG,CAAC,IAAI,EAAC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAC,IAAI,CAAC;EACtD;EACA,IAAII,EAAE,IAAIA,EAAE,CAACS,MAAM,KAAK,SAAS,EAAE,OAAO,CAAC,IAAI,EAAC,IAAI,CAAC;EACrD,IAAIP,EAAE,IAAIA,EAAE,CAACO,MAAM,KAAK,SAAS,EAAE,OAAO,CAAC,IAAI,EAAC,IAAI,CAAC;EACrD;EACA,OAAO,CAAC,IAAI,EAAC,IAAI,CAAC;AACpB;AAEA,SAASS,UAAUA,CAACZ,EAAE,EAAEC,GAAG,EAAE;EAC3B,MAAMjC,IAAI,GAAG1B,cAAc,CAAC0D,EAAE,CAACa,IAAI,CAACY,IAAI,EAAEzB,EAAE,CAACwB,KAAK,CAAC;EACnD,MAAMvD,GAAG,GAAIvB,iBAAiB,CAACsD,EAAE,CAACa,IAAI,CAACY,IAAI,EAAExB,GAAG,CAACuB,KAAK,CAAC;EACvD,MAAMtD,SAAS,GAAGK,mBAAmB,CAACyB,EAAE,CAACxB,SAAS,EAAEyB,GAAG,CAACxB,SAAS,CAAC;EAClE,OAAOX,SAAS,CAACkC,EAAE,CAACa,IAAI,CAAC9C,KAAK,EAAEiC,EAAE,CAACT,KAAK,CAAC7B,GAAG,EAAEuC,GAAG,CAACV,KAAK,CAAC5B,GAAG,EAAEK,IAAI,EAAEC,GAAG,EAAEC,SAAS,CAAC;AACpF;AAEA,SAASqC,aAAaA,CAACP,EAAE,EAAEC,GAAG,EAAE;EAC9B,MAAMQ,IAAI,GAAGT,EAAE,CAACE,OAAO,CAACO,IAAI;EAC5B,MAAMzC,IAAI,GAAG1B,cAAc,CAACmE,IAAI,CAACgB,IAAI,EAAEzB,EAAE,CAACwB,KAAK,CAAC;EAChD,MAAMvD,GAAG,GAAIvB,iBAAiB,CAAC+D,IAAI,CAACgB,IAAI,EAAExB,GAAG,CAACuB,KAAK,CAAC;EACpD,MAAMtD,SAAS,GAAGK,mBAAmB,CAACyB,EAAE,CAACxB,SAAS,EAAEyB,GAAG,CAACxB,SAAS,CAAC;EAClE,OAAOX,SAAS,CAAC2C,IAAI,CAAC1C,KAAK,EAAEiC,EAAE,CAACT,KAAK,CAAC7B,GAAG,EAAEuC,GAAG,CAACV,KAAK,CAAC5B,GAAG,EAAEK,IAAI,EAAEC,GAAG,EAAEC,SAAS,CAAC;AACjF;AAEA,SAASsC,UAAUA,CAACR,EAAE,EAAEC,GAAG,EAAEQ,IAAI,EAAE;EAAA,IAAA6B,qBAAA,EAAAC,mBAAA,EAAAC,mBAAA;EACjC,IAAI,CAAC/B,IAAI,CAACgC,IAAI,EAAE;EAChB,MAAMC,MAAM,IAAAJ,qBAAA,GAAG7B,IAAI,CAACgC,IAAI,CAACE,WAAW,cAAAL,qBAAA,cAAAA,qBAAA,GAAI,GAAG;EAC3C,IAAII,MAAM,GAAG,CAAC,EAAE;IACd;IACA;IACA,IAAIA,MAAM,KAAK,CAAC,EAAE;EACpB;EACA,MAAME,QAAQ,IAAAL,mBAAA,GAAG9B,IAAI,CAACgC,IAAI,CAACI,QAAQ,cAAAN,mBAAA,cAAAA,mBAAA,GAAI,CAAC;EACxC,MAAMO,QAAQ,IAAAN,mBAAA,GAAG/B,IAAI,CAACgC,IAAI,CAACM,QAAQ,cAAAP,mBAAA,cAAAA,mBAAA,GAAI,CAAC;EACxC,IAAI/B,IAAI,CAACgC,IAAI,CAACO,MAAM,KAAK,MAAM,EAAE;IAC/BhD,EAAE,CAACxB,SAAS,GAAGvC,KAAK,CAAC+D,EAAE,CAACxB,SAAS,GAAGoE,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;IACpD5C,EAAE,CAACvB,SAAS,GAAGxC,KAAK,CAAC+D,EAAE,CAACvB,SAAS,GAAGqE,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EACtD,CAAC,MAAM;IACL7C,GAAG,CAACzB,SAAS,GAAGvC,KAAK,CAACgE,GAAG,CAACzB,SAAS,GAAGoE,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;IACtD3C,GAAG,CAACxB,SAAS,GAAGxC,KAAK,CAACgE,GAAG,CAACxB,SAAS,GAAGqE,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EACxD;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}