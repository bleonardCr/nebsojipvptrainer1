{"ast":null,"code":"// Lightweight PvP calc for \"pick 3 of yours vs ONE enemy\" with shields.\n// Uses move power/energy from gamemaster.json (or sensible defaults).\n\n// ---------- Build a move lookup from gamemaster ----------\nexport function buildMoveBook(gm) {\n  var _gm$data;\n  const book = {};\n  const list = Array.isArray(gm === null || gm === void 0 ? void 0 : gm.moves) ? gm.moves : Array.isArray(gm === null || gm === void 0 ? void 0 : (_gm$data = gm.data) === null || _gm$data === void 0 ? void 0 : _gm$data.moves) ? gm.data.moves : Array.isArray(gm === null || gm === void 0 ? void 0 : gm.moveList) ? gm.moveList : [];\n  for (const m of list) {\n    var _ref, _m$moveType, _m$power, _m$energyGain, _m$energy;\n    const id = m.moveId || m.id || m.name;\n    if (!id) continue;\n    const isFast = ((_ref = (_m$moveType = m.moveType) !== null && _m$moveType !== void 0 ? _m$moveType : m.kind) !== null && _ref !== void 0 ? _ref : \"\").toString().toLowerCase().includes(\"fast\") || m.energyGain != null;\n    book[id] = {\n      id,\n      kind: isFast ? \"fast\" : \"charged\",\n      power: Number((_m$power = m.power) !== null && _m$power !== void 0 ? _m$power : 0),\n      energyGain: isFast ? Math.abs(Number((_m$energyGain = m.energyGain) !== null && _m$energyGain !== void 0 ? _m$energyGain : 9)) : 0,\n      // charged \"energy\" is cost (negative)\n      energy: isFast ? 0 : -Math.abs(Number((_m$energy = m.energy) !== null && _m$energy !== void 0 ? _m$energy : 45)),\n      type: m.type || \"Neutral\"\n    };\n  }\n  return book;\n}\nfunction defaultFast() {\n  return {\n    id: \"FAST_DEFAULT\",\n    kind: \"fast\",\n    power: 3,\n    energyGain: 9,\n    type: \"Neutral\"\n  };\n}\nfunction defaultCharged() {\n  return {\n    id: \"CHARGE_DEFAULT\",\n    kind: \"charged\",\n    power: 70,\n    energy: -45,\n    type: \"Neutral\"\n  };\n}\n\n// Choose the best charged by DPE (power / energy cost)\nfunction bestCharged(ids = [], book) {\n  let best = null,\n    bestDpe = -Infinity;\n  for (const id of ids) {\n    const m = book[id] || defaultCharged();\n    const cost = Math.abs(m.energy || 45) || 45;\n    const dpe = (m.power || 0) / cost;\n    if (dpe > bestDpe) {\n      bestDpe = dpe;\n      best = {\n        ...m,\n        id,\n        dpe\n      };\n    }\n  }\n  return best;\n}\n\n// ---------- One-on-one quick sim ----------\nexport function simulateDuel(attacker, defender, shieldsA, shieldsB, book) {\n  var _A$rec, _B$rec;\n  // attacker/defender must have { name, fastMove, chargedMoves[] }\n  const A = {\n    name: attacker.name,\n    hp: 100,\n    energy: 0,\n    shields: shieldsA,\n    fast: book[attacker.fastMove] || defaultFast(),\n    charged: (attacker.chargedMoves || []).map(id => ({\n      ...(book[id] || defaultCharged()),\n      id\n    })),\n    rec: bestCharged(attacker.chargedMoves, book)\n  };\n  const B = {\n    name: defender.name,\n    hp: 100,\n    energy: 0,\n    shields: shieldsB,\n    fast: book[defender.fastMove] || defaultFast(),\n    charged: (defender.chargedMoves || []).map(id => ({\n      ...(book[id] || defaultCharged()),\n      id\n    })),\n    rec: bestCharged(defender.chargedMoves, book)\n  };\n  const log = [];\n  let turn = 0;\n  const MAX_TURNS = 300;\n  function pickCharged(pokemon) {\n    if (!pokemon.charged.length) return null;\n    // pick the highest DPE you can currently afford\n    const sorted = pokemon.charged.map(m => ({\n      m,\n      cost: Math.abs(m.energy || 45),\n      dpe: (m.power || 0) / (Math.abs(m.energy || 45) || 45)\n    })).sort((a, b) => b.dpe - a.dpe);\n    const affordable = sorted.find(x => pokemon.energy >= x.cost);\n    return (affordable === null || affordable === void 0 ? void 0 : affordable.m) || null;\n  }\n  while (A.hp > 0 && B.hp > 0 && turn < MAX_TURNS) {\n    turn++;\n\n    // Fast-move ticks (very rough, one \"turn\" each)\n    A.energy += A.fast.energyGain || 0;\n    B.energy += B.fast.energyGain || 0;\n\n    // A acts\n    const aCharge = pickCharged(A);\n    if (aCharge) {\n      if (B.shields > 0) {\n        B.shields--;\n        log.push(`${A.name} throws ${aCharge.id} (shielded)`);\n      } else {\n        B.hp -= Math.max(1, aCharge.power || 0);\n        log.push(`${A.name} hits ${B.name} with ${aCharge.id} for ${aCharge.power}`);\n      }\n      A.energy += aCharge.energy || -45; // spend energy\n    } else {\n      B.hp -= Math.max(1, A.fast.power || 1);\n    }\n    if (B.hp <= 0) break;\n\n    // B acts\n    const bCharge = pickCharged(B);\n    if (bCharge) {\n      if (A.shields > 0) {\n        A.shields--;\n        log.push(`${B.name} throws ${bCharge.id} (shielded)`);\n      } else {\n        A.hp -= Math.max(1, bCharge.power || 0);\n        log.push(`${B.name} hits ${A.name} with ${bCharge.id} for ${bCharge.power}`);\n      }\n      B.energy += bCharge.energy || -45;\n    } else {\n      A.hp -= Math.max(1, B.fast.power || 1);\n    }\n  }\n  const winner = A.hp <= 0 && B.hp <= 0 ? \"Draw\" : A.hp <= 0 ? B.name : B.hp <= 0 ? A.name : A.hp === B.hp ? \"Draw\" : A.hp > B.hp ? A.name : B.name;\n  return {\n    winner,\n    aHP: Math.max(0, Math.round(A.hp)),\n    bHP: Math.max(0, Math.round(B.hp)),\n    aRecommended: ((_A$rec = A.rec) === null || _A$rec === void 0 ? void 0 : _A$rec.id) || null,\n    bRecommended: ((_B$rec = B.rec) === null || _B$rec === void 0 ? void 0 : _B$rec.id) || null,\n    summary: log.slice(0, 12) // short summary\n  };\n}\n\n// ---------- Rank your 3 vs one enemy ----------\nexport function bestOfThree(mine, enemy, myShields, foeShields, book) {\n  const fights = mine.map(m => {\n    const r = simulateDuel(m, enemy, myShields, foeShields, book);\n    const score = r.winner === m.name ? 1 : r.winner === \"Draw\" ? 0 : -1;\n    const margin = r.aHP - r.bHP;\n    return {\n      you: m.name,\n      vs: enemy.name,\n      ...r,\n      score,\n      margin\n    };\n  });\n  fights.sort((a, b) => b.score - a.score || b.margin - a.margin);\n  return {\n    best: fights[0],\n    fights\n  };\n}","map":{"version":3,"names":["buildMoveBook","gm","_gm$data","book","list","Array","isArray","moves","data","moveList","m","_ref","_m$moveType","_m$power","_m$energyGain","_m$energy","id","moveId","name","isFast","moveType","kind","toString","toLowerCase","includes","energyGain","power","Number","Math","abs","energy","type","defaultFast","defaultCharged","bestCharged","ids","best","bestDpe","Infinity","cost","dpe","simulateDuel","attacker","defender","shieldsA","shieldsB","_A$rec","_B$rec","A","hp","shields","fast","fastMove","charged","chargedMoves","map","rec","B","log","turn","MAX_TURNS","pickCharged","pokemon","length","sorted","sort","a","b","affordable","find","x","aCharge","push","max","bCharge","winner","aHP","round","bHP","aRecommended","bRecommended","summary","slice","bestOfThree","mine","enemy","myShields","foeShields","fights","r","score","margin","you","vs"],"sources":["C:/Users/ben/Projects/nebsojipvptrainer/src/battleCalc.js"],"sourcesContent":["// Lightweight PvP calc for \"pick 3 of yours vs ONE enemy\" with shields.\r\n// Uses move power/energy from gamemaster.json (or sensible defaults).\r\n\r\n// ---------- Build a move lookup from gamemaster ----------\r\nexport function buildMoveBook(gm) {\r\n    const book = {};\r\n    const list =\r\n        Array.isArray(gm?.moves) ? gm.moves :\r\n            Array.isArray(gm?.data?.moves) ? gm.data.moves :\r\n                Array.isArray(gm?.moveList) ? gm.moveList : [];\r\n\r\n    for (const m of list) {\r\n        const id = m.moveId || m.id || m.name;\r\n        if (!id) continue;\r\n        const isFast =\r\n            (m.moveType ?? m.kind ?? \"\").toString().toLowerCase().includes(\"fast\") ||\r\n            (m.energyGain != null);\r\n\r\n        book[id] = {\r\n            id,\r\n            kind: isFast ? \"fast\" : \"charged\",\r\n            power: Number(m.power ?? 0),\r\n            energyGain: isFast ? Math.abs(Number(m.energyGain ?? 9)) : 0,\r\n            // charged \"energy\" is cost (negative)\r\n            energy: isFast ? 0 : -Math.abs(Number(m.energy ?? 45)),\r\n            type: m.type || \"Neutral\"\r\n        };\r\n    }\r\n    return book;\r\n}\r\n\r\nfunction defaultFast() { return { id: \"FAST_DEFAULT\", kind: \"fast\", power: 3, energyGain: 9, type: \"Neutral\" }; }\r\nfunction defaultCharged() { return { id: \"CHARGE_DEFAULT\", kind: \"charged\", power: 70, energy: -45, type: \"Neutral\" }; }\r\n\r\n// Choose the best charged by DPE (power / energy cost)\r\nfunction bestCharged(ids = [], book) {\r\n    let best = null, bestDpe = -Infinity;\r\n    for (const id of ids) {\r\n        const m = book[id] || defaultCharged();\r\n        const cost = Math.abs(m.energy || 45) || 45;\r\n        const dpe = (m.power || 0) / cost;\r\n        if (dpe > bestDpe) { bestDpe = dpe; best = { ...m, id, dpe }; }\r\n    }\r\n    return best;\r\n}\r\n\r\n// ---------- One-on-one quick sim ----------\r\nexport function simulateDuel(attacker, defender, shieldsA, shieldsB, book) {\r\n    // attacker/defender must have { name, fastMove, chargedMoves[] }\r\n    const A = {\r\n        name: attacker.name,\r\n        hp: 100, energy: 0, shields: shieldsA,\r\n        fast: (book[attacker.fastMove] || defaultFast()),\r\n        charged: (attacker.chargedMoves || []).map(id => ({ ...(book[id] || defaultCharged()), id })),\r\n        rec: bestCharged(attacker.chargedMoves, book)\r\n    };\r\n    const B = {\r\n        name: defender.name,\r\n        hp: 100, energy: 0, shields: shieldsB,\r\n        fast: (book[defender.fastMove] || defaultFast()),\r\n        charged: (defender.chargedMoves || []).map(id => ({ ...(book[id] || defaultCharged()), id })),\r\n        rec: bestCharged(defender.chargedMoves, book)\r\n    };\r\n\r\n    const log = [];\r\n    let turn = 0;\r\n    const MAX_TURNS = 300;\r\n\r\n    function pickCharged(pokemon) {\r\n        if (!pokemon.charged.length) return null;\r\n        // pick the highest DPE you can currently afford\r\n        const sorted = pokemon.charged\r\n            .map(m => ({ m, cost: Math.abs(m.energy || 45), dpe: (m.power || 0) / (Math.abs(m.energy || 45) || 45) }))\r\n            .sort((a, b) => b.dpe - a.dpe);\r\n        const affordable = sorted.find(x => pokemon.energy >= x.cost);\r\n        return affordable?.m || null;\r\n    }\r\n\r\n    while (A.hp > 0 && B.hp > 0 && turn < MAX_TURNS) {\r\n        turn++;\r\n\r\n        // Fast-move ticks (very rough, one \"turn\" each)\r\n        A.energy += A.fast.energyGain || 0;\r\n        B.energy += B.fast.energyGain || 0;\r\n\r\n        // A acts\r\n        const aCharge = pickCharged(A);\r\n        if (aCharge) {\r\n            if (B.shields > 0) {\r\n                B.shields--; log.push(`${A.name} throws ${aCharge.id} (shielded)`);\r\n            } else {\r\n                B.hp -= Math.max(1, aCharge.power || 0);\r\n                log.push(`${A.name} hits ${B.name} with ${aCharge.id} for ${aCharge.power}`);\r\n            }\r\n            A.energy += aCharge.energy || -45; // spend energy\r\n        } else {\r\n            B.hp -= Math.max(1, A.fast.power || 1);\r\n        }\r\n        if (B.hp <= 0) break;\r\n\r\n        // B acts\r\n        const bCharge = pickCharged(B);\r\n        if (bCharge) {\r\n            if (A.shields > 0) {\r\n                A.shields--; log.push(`${B.name} throws ${bCharge.id} (shielded)`);\r\n            } else {\r\n                A.hp -= Math.max(1, bCharge.power || 0);\r\n                log.push(`${B.name} hits ${A.name} with ${bCharge.id} for ${bCharge.power}`);\r\n            }\r\n            B.energy += bCharge.energy || -45;\r\n        } else {\r\n            A.hp -= Math.max(1, B.fast.power || 1);\r\n        }\r\n    }\r\n\r\n    const winner =\r\n        A.hp <= 0 && B.hp <= 0 ? \"Draw\" :\r\n            A.hp <= 0 ? B.name :\r\n                B.hp <= 0 ? A.name :\r\n                    (A.hp === B.hp ? \"Draw\" : (A.hp > B.hp ? A.name : B.name));\r\n\r\n    return {\r\n        winner,\r\n        aHP: Math.max(0, Math.round(A.hp)),\r\n        bHP: Math.max(0, Math.round(B.hp)),\r\n        aRecommended: A.rec?.id || null,\r\n        bRecommended: B.rec?.id || null,\r\n        summary: log.slice(0, 12) // short summary\r\n    };\r\n}\r\n\r\n// ---------- Rank your 3 vs one enemy ----------\r\nexport function bestOfThree(mine, enemy, myShields, foeShields, book) {\r\n    const fights = mine.map(m => {\r\n        const r = simulateDuel(m, enemy, myShields, foeShields, book);\r\n        const score = r.winner === m.name ? 1 : (r.winner === \"Draw\" ? 0 : -1);\r\n        const margin = r.aHP - r.bHP;\r\n        return { you: m.name, vs: enemy.name, ...r, score, margin };\r\n    });\r\n    fights.sort((a, b) => (b.score - a.score) || (b.margin - a.margin));\r\n    return { best: fights[0], fights };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}