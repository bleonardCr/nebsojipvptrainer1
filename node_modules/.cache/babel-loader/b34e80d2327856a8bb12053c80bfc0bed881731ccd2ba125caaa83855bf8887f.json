{"ast":null,"code":"// pick charged with highest actual damage vs current foe (unchanged)\nfunction bestCharged(att, def) {\n  let best = null,\n    bestVal = -Infinity;\n  for (const m of att.chargedMoves || []) {\n    if (!m || m.kind !== \"charged\") continue;\n    const stab = att.types.includes(m.type) ? STAB : 1;\n    const mult = eff(m.type, def.types);\n    const val = dmg(m.power, att.Atk, def.Def, stab, mult);\n    if (val > bestVal) {\n      bestVal = val;\n      best = m;\n    }\n  }\n  return best;\n}\n\n// --- FIXED: use attacker's stats & typing to estimate incoming damage ---\nfunction shouldShield(attacker, defender, incomingMove, shieldsLeft) {\n  if (shieldsLeft <= 0) return false;\n  const stab = attacker.types.includes(incomingMove.type) ? STAB : 1;\n  const mult = eff(incomingMove.type, defender.types);\n  const hit = dmg(incomingMove.power, attacker.Atk, defender.Def, stab, mult);\n  // More liberal with 2 shields; stricter with 1\n  const threshold = shieldsLeft === 2 ? 0.32 : 0.45;\n  return hit >= defender.HP || hit >= defender.MaxHP * threshold;\n}\nwhile (A.HP > 0 && B.HP > 0 && t < MAX_TURNS) {\n  t++;\n  const aReady = canThrow(A);\n  const bReady = canThrow(B);\n  if (aReady || bReady) {\n    const aFirst = aReady && (!bReady || A.Atk >= B.Atk);\n    const resolve = (attacker, defender, who) => {\n      var _attacker$fast;\n      const move = chooseThrow(attacker, defender);\n      if (!move) return;\n      let shielded = false;\n      if (who === \"A\" ? shouldShield(attacker, defender, move, bSh) : shouldShield(attacker, defender, move, aSh)) {\n        if (who === \"A\") bSh--;else aSh--;\n        shielded = true;\n      } else {\n        const stab = attacker.types.includes(move.type) ? STAB : 1;\n        const mult = eff(move.type, defender.types);\n        const hit = dmg(move.power, attacker.Atk, defender.Def, stab, mult);\n        defender.HP = Math.max(0, defender.HP - hit);\n      }\n      attacker.energy -= move.energyCost || 45;\n      attacker.cooldown = ((_attacker$fast = attacker.fast) === null || _attacker$fast === void 0 ? void 0 : _attacker$fast.turns) || 1; // charged consumes the turn\n      log.push(`${who} throws ${move.id}${shielded ? \" (shielded)\" : \"\"}`);\n    };\n    if (aFirst) {\n      resolve(A, B, \"A\");\n      if (B.HP <= 0) break;\n      if (bReady) resolve(B, A, \"B\");\n      if (A.HP <= 0) break;\n    } else {\n      resolve(B, A, \"B\");\n      if (A.HP <= 0) break;\n      if (aReady) resolve(A, B, \"A\");\n      if (B.HP <= 0) break;\n    }\n    continue; // no fast damage on a charged turn\n  }\n\n  // fast turns (unchanged)\n  tryFast(A, B);\n  if (B.HP <= 0) break;\n  tryFast(B, A);\n  if (A.HP <= 0) break;\n}","map":{"version":3,"names":["bestCharged","att","def","best","bestVal","Infinity","m","chargedMoves","kind","stab","types","includes","type","STAB","mult","eff","val","dmg","power","Atk","Def","shouldShield","attacker","defender","incomingMove","shieldsLeft","hit","threshold","HP","MaxHP","A","B","t","MAX_TURNS","aReady","canThrow","bReady","aFirst","resolve","who","_attacker$fast","move","chooseThrow","shielded","bSh","aSh","Math","max","energy","energyCost","cooldown","fast","turns","log","push","id","tryFast"],"sources":["C:/Users/ben/Projects/nebsojipvptrainer/src/battleCalc.js"],"sourcesContent":["// pick charged with highest actual damage vs current foe (unchanged)\r\nfunction bestCharged(att, def) {\r\n    let best = null, bestVal = -Infinity;\r\n    for (const m of (att.chargedMoves || [])) {\r\n        if (!m || m.kind !== \"charged\") continue;\r\n        const stab = att.types.includes(m.type) ? STAB : 1;\r\n        const mult = eff(m.type, def.types);\r\n        const val = dmg(m.power, att.Atk, def.Def, stab, mult);\r\n        if (val > bestVal) { bestVal = val; best = m; }\r\n    }\r\n    return best;\r\n}\r\n\r\n// --- FIXED: use attacker's stats & typing to estimate incoming damage ---\r\nfunction shouldShield(attacker, defender, incomingMove, shieldsLeft) {\r\n    if (shieldsLeft <= 0) return false;\r\n    const stab = attacker.types.includes(incomingMove.type) ? STAB : 1;\r\n    const mult = eff(incomingMove.type, defender.types);\r\n    const hit = dmg(incomingMove.power, attacker.Atk, defender.Def, stab, mult);\r\n    // More liberal with 2 shields; stricter with 1\r\n    const threshold = shieldsLeft === 2 ? 0.32 : 0.45;\r\n    return hit >= defender.HP || hit >= defender.MaxHP * threshold;\r\n}\r\n\r\nwhile (A.HP > 0 && B.HP > 0 && t < MAX_TURNS) {\r\n    t++;\r\n\r\n    const aReady = canThrow(A);\r\n    const bReady = canThrow(B);\r\n\r\n    if (aReady || bReady) {\r\n        const aFirst = aReady && (!bReady || (A.Atk >= B.Atk));\r\n\r\n        const resolve = (attacker, defender, who) => {\r\n            const move = chooseThrow(attacker, defender);\r\n            if (!move) return;\r\n            let shielded = false;\r\n            if (who === \"A\" ? shouldShield(attacker, defender, move, bSh)\r\n                : shouldShield(attacker, defender, move, aSh)) {\r\n                if (who === \"A\") bSh--; else aSh--;\r\n                shielded = true;\r\n            } else {\r\n                const stab = attacker.types.includes(move.type) ? STAB : 1;\r\n                const mult = eff(move.type, defender.types);\r\n                const hit = dmg(move.power, attacker.Atk, defender.Def, stab, mult);\r\n                defender.HP = Math.max(0, defender.HP - hit);\r\n            }\r\n            attacker.energy -= (move.energyCost || 45);\r\n            attacker.cooldown = attacker.fast?.turns || 1; // charged consumes the turn\r\n            log.push(`${who} throws ${move.id}${shielded ? \" (shielded)\" : \"\"}`);\r\n        };\r\n\r\n        if (aFirst) {\r\n            resolve(A, B, \"A\");\r\n            if (B.HP <= 0) break;\r\n            if (bReady) resolve(B, A, \"B\");\r\n            if (A.HP <= 0) break;\r\n        } else {\r\n            resolve(B, A, \"B\");\r\n            if (A.HP <= 0) break;\r\n            if (aReady) resolve(A, B, \"A\");\r\n            if (B.HP <= 0) break;\r\n        }\r\n\r\n        continue; // no fast damage on a charged turn\r\n    }\r\n\r\n    // fast turns (unchanged)\r\n    tryFast(A, B);\r\n    if (B.HP <= 0) break;\r\n    tryFast(B, A);\r\n    if (A.HP <= 0) break;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}