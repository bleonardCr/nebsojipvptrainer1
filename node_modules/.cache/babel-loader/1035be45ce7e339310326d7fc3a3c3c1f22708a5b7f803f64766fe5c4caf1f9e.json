{"ast":null,"code":"// src/Engine/battleEngine.js\n// Accurate turn-based PvP battle simulation using PvPoke-style data\n\nimport gamemaster from \"../data/gamemaster.json\";\n\n// --- Data maps ---\nconst POKEDEX = {};\nconst MOVES = {};\n(gamemaster.pokemon || []).forEach(p => {\n  POKEDEX[p.speciesId] = p;\n});\n(gamemaster.moves || []).forEach(m => {\n  MOVES[m.moveId] = m;\n});\n\n// --- Helpers ---\nfunction applyCPM(stat, level) {\n  // PvPoke base stats already CP-normalized for 1500/2500/? leagues\n  return stat;\n}\nfunction calculateDamage(attacker, defender, move) {\n  const atk = applyCPM(attacker.stats.atk, attacker.level);\n  const def = applyCPM(defender.stats.def, defender.level);\n  let base = Math.floor(0.5 * move.power * (atk / def) * 1.3 + 1);\n\n  // STAB\n  if (attacker.types.includes(move.type)) {\n    base = Math.floor(base * 1.2);\n  }\n\n  // Type effectiveness\n  const mult = typeEffectiveness(move.type, defender.types);\n  base = Math.floor(base * mult);\n  return Math.max(1, base);\n}\nfunction typeEffectiveness(moveType, defenderTypes) {\n  // PvPoke gamemaster has typeEffectiveness\n  let mult = 1;\n  defenderTypes.forEach(t => {\n    var _gamemaster$typeEffec;\n    const rel = (_gamemaster$typeEffec = gamemaster.typeEffectiveness[moveType]) === null || _gamemaster$typeEffec === void 0 ? void 0 : _gamemaster$typeEffec[t];\n    if (rel) mult *= rel;\n  });\n  return mult;\n}\n\n// --- Main battle sim ---\nexport function simulateBattle(pokemonA, pokemonB, shieldsA, shieldsB) {\n  const a = createBattler(pokemonA);\n  const b = createBattler(pokemonB);\n  a.shields = shieldsA;\n  b.shields = shieldsB;\n  let turn = 0;\n  const MAX_TURNS = 500;\n  while (a.hp > 0 && b.hp > 0 && turn < MAX_TURNS) {\n    turn++;\n\n    // Each Pok�mon decides action\n    takeTurn(a, b);\n    if (b.hp <= 0) break;\n    takeTurn(b, a);\n  }\n  let result;\n  if (a.hp <= 0 && b.hp <= 0) result = \"draw\";else if (a.hp <= 0) result = \"loss\";else result = \"win\";\n  return {\n    result,\n    remainingHpA: a.hp,\n    remainingHpB: b.hp,\n    turns: turn\n  };\n}\n\n// --- Turn logic ---\nfunction takeTurn(attacker, defender) {\n  attacker.cooldown--;\n  if (attacker.cooldown > 0) {\n    return; // still waiting for fast move cooldown\n  }\n\n  // Use charged move if possible and beneficial\n  const chargedMove = attacker.moves.charged[0];\n  if (attacker.energy >= chargedMove.energy) {\n    if (defender.shields > 0) {\n      defender.shields--;\n    } else {\n      defender.hp -= calculateDamage(attacker, defender, chargedMove);\n    }\n    attacker.energy -= chargedMove.energy;\n    attacker.cooldown = chargedMove.cooldown || 1;\n    return;\n  }\n\n  // Otherwise, use fast move\n  const fastMove = attacker.moves.fast;\n  defender.hp -= calculateDamage(attacker, defender, fastMove);\n  attacker.energy += fastMove.energyGain;\n  attacker.cooldown = fastMove.cooldown || 1;\n}\nfunction createBattler(pokemon) {\n  const base = POKEDEX[pokemon.speciesId];\n  const fastMoveData = MOVES[pokemon.fastMove];\n  const chargedMovesData = pokemon.chargedMoves.map(id => MOVES[id]);\n  return {\n    speciesId: pokemon.speciesId,\n    types: base.types,\n    stats: {\n      atk: base.stats.atk,\n      def: base.stats.def,\n      hp: base.stats.hp\n    },\n    hp: base.stats.hp,\n    energy: 0,\n    cooldown: 0,\n    shields: 0,\n    level: pokemon.level || 40,\n    moves: {\n      fast: fastMoveData,\n      charged: chargedMovesData\n    }\n  };\n}","map":{"version":3,"names":["gamemaster","POKEDEX","MOVES","pokemon","forEach","p","speciesId","moves","m","moveId","applyCPM","stat","level","calculateDamage","attacker","defender","move","atk","stats","def","base","Math","floor","power","types","includes","type","mult","typeEffectiveness","max","moveType","defenderTypes","t","_gamemaster$typeEffec","rel","simulateBattle","pokemonA","pokemonB","shieldsA","shieldsB","a","createBattler","b","shields","turn","MAX_TURNS","hp","takeTurn","result","remainingHpA","remainingHpB","turns","cooldown","chargedMove","charged","energy","fastMove","fast","energyGain","fastMoveData","chargedMovesData","chargedMoves","map","id"],"sources":["C:/Users/ben/Projects/nebsojipvptrainer/src/engine/battleEngine.js"],"sourcesContent":["// src/Engine/battleEngine.js\r\n// Accurate turn-based PvP battle simulation using PvPoke-style data\r\n\r\nimport gamemaster from \"../data/gamemaster.json\";\r\n\r\n// --- Data maps ---\r\nconst POKEDEX = {};\r\nconst MOVES = {};\r\n\r\n(gamemaster.pokemon || []).forEach(p => {\r\n    POKEDEX[p.speciesId] = p;\r\n});\r\n(gamemaster.moves || []).forEach(m => {\r\n    MOVES[m.moveId] = m;\r\n});\r\n\r\n// --- Helpers ---\r\nfunction applyCPM(stat, level) {\r\n    // PvPoke base stats already CP-normalized for 1500/2500/? leagues\r\n    return stat;\r\n}\r\n\r\nfunction calculateDamage(attacker, defender, move) {\r\n    const atk = applyCPM(attacker.stats.atk, attacker.level);\r\n    const def = applyCPM(defender.stats.def, defender.level);\r\n\r\n    let base = Math.floor(\r\n        (0.5 * move.power * (atk / def) * 1.3) + 1\r\n    );\r\n\r\n    // STAB\r\n    if (attacker.types.includes(move.type)) {\r\n        base = Math.floor(base * 1.2);\r\n    }\r\n\r\n    // Type effectiveness\r\n    const mult = typeEffectiveness(move.type, defender.types);\r\n    base = Math.floor(base * mult);\r\n\r\n    return Math.max(1, base);\r\n}\r\n\r\nfunction typeEffectiveness(moveType, defenderTypes) {\r\n    // PvPoke gamemaster has typeEffectiveness\r\n    let mult = 1;\r\n    defenderTypes.forEach(t => {\r\n        const rel = gamemaster.typeEffectiveness[moveType]?.[t];\r\n        if (rel) mult *= rel;\r\n    });\r\n    return mult;\r\n}\r\n\r\n// --- Main battle sim ---\r\nexport function simulateBattle(pokemonA, pokemonB, shieldsA, shieldsB) {\r\n    const a = createBattler(pokemonA);\r\n    const b = createBattler(pokemonB);\r\n\r\n    a.shields = shieldsA;\r\n    b.shields = shieldsB;\r\n\r\n    let turn = 0;\r\n    const MAX_TURNS = 500;\r\n\r\n    while (a.hp > 0 && b.hp > 0 && turn < MAX_TURNS) {\r\n        turn++;\r\n\r\n        // Each Pok�mon decides action\r\n        takeTurn(a, b);\r\n        if (b.hp <= 0) break;\r\n        takeTurn(b, a);\r\n    }\r\n\r\n    let result;\r\n    if (a.hp <= 0 && b.hp <= 0) result = \"draw\";\r\n    else if (a.hp <= 0) result = \"loss\";\r\n    else result = \"win\";\r\n\r\n    return {\r\n        result,\r\n        remainingHpA: a.hp,\r\n        remainingHpB: b.hp,\r\n        turns: turn\r\n    };\r\n}\r\n\r\n// --- Turn logic ---\r\nfunction takeTurn(attacker, defender) {\r\n    attacker.cooldown--;\r\n\r\n    if (attacker.cooldown > 0) {\r\n        return; // still waiting for fast move cooldown\r\n    }\r\n\r\n    // Use charged move if possible and beneficial\r\n    const chargedMove = attacker.moves.charged[0];\r\n    if (attacker.energy >= chargedMove.energy) {\r\n        if (defender.shields > 0) {\r\n            defender.shields--;\r\n        } else {\r\n            defender.hp -= calculateDamage(attacker, defender, chargedMove);\r\n        }\r\n        attacker.energy -= chargedMove.energy;\r\n        attacker.cooldown = chargedMove.cooldown || 1;\r\n        return;\r\n    }\r\n\r\n    // Otherwise, use fast move\r\n    const fastMove = attacker.moves.fast;\r\n    defender.hp -= calculateDamage(attacker, defender, fastMove);\r\n    attacker.energy += fastMove.energyGain;\r\n    attacker.cooldown = fastMove.cooldown || 1;\r\n}\r\n\r\nfunction createBattler(pokemon) {\r\n    const base = POKEDEX[pokemon.speciesId];\r\n    const fastMoveData = MOVES[pokemon.fastMove];\r\n    const chargedMovesData = pokemon.chargedMoves.map(id => MOVES[id]);\r\n\r\n    return {\r\n        speciesId: pokemon.speciesId,\r\n        types: base.types,\r\n        stats: {\r\n            atk: base.stats.atk,\r\n            def: base.stats.def,\r\n            hp: base.stats.hp\r\n        },\r\n        hp: base.stats.hp,\r\n        energy: 0,\r\n        cooldown: 0,\r\n        shields: 0,\r\n        level: pokemon.level || 40,\r\n        moves: {\r\n            fast: fastMoveData,\r\n            charged: chargedMovesData\r\n        }\r\n    };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}