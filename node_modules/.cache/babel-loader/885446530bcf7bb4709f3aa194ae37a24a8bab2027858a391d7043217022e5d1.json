{"ast":null,"code":"// pick charged with highest *actual* damage vs current foe (unchanged in your file)\nfunction bestCharged(att, def) {\n  let best = null,\n    bestVal = -Infinity;\n  for (const m of att.chargedMoves || []) {\n    if (!m || m.kind !== \"charged\") continue;\n    const stab = att.types.includes(m.type) ? STAB : 1;\n    const mult = eff(m.type, def.types);\n    const val = dmg(m.power, att.Atk, def.Def, stab, mult);\n    if (val > bestVal) {\n      bestVal = val;\n      best = m;\n    }\n  }\n  return best;\n}\n\n// --- FIX: estimate incoming damage with the *attacker's* stats/typing\nfunction shouldShield(attacker, defender, incomingMove, shieldsLeft) {\n  if (shieldsLeft <= 0) return false;\n  const stab = attacker.types.includes(incomingMove.type) ? STAB : 1;\n  const mult = eff(incomingMove.type, defender.types);\n  const hit = dmg(incomingMove.power, attacker.Atk, defender.Def, stab, mult);\n  const threshold = shieldsLeft === 2 ? 0.32 : 0.45; // tune if you like\n  return hit >= defender.HP || hit >= defender.MaxHP * threshold;\n}\nexport function simulateDuel(attackerIn, defenderIn, shieldsA = 2, shieldsB = 2, _book = MOVES, leagueName = \"Master League\") {\n  var _bestCharged, _bestCharged2, _A$fast, _B$fast;\n  const A = buildFighter(attackerIn, leagueName);\n  const B = buildFighter(defenderIn, leagueName);\n  const recA = ((_bestCharged = bestCharged(A, B)) === null || _bestCharged === void 0 ? void 0 : _bestCharged.id) || null;\n  const recB = ((_bestCharged2 = bestCharged(B, A)) === null || _bestCharged2 === void 0 ? void 0 : _bestCharged2.id) || null;\n  let aSh = Math.max(0, shieldsA | 0),\n    bSh = Math.max(0, shieldsB | 0);\n  let t = 0;\n  const MAX_TURNS = 2000;\n  const log = [];\n  function progressFast(user, foe) {\n    if (!user.fast) return;\n    user.cooldown--;\n    if (user.cooldown <= 0) {\n      const stab = user.types.includes(user.fast.type) ? STAB : 1;\n      const mult = eff(user.fast.type, foe.types);\n      const hit = dmg(user.fast.power, user.Atk, foe.Def, stab, mult);\n      foe.HP = Math.max(0, foe.HP - hit);\n      user.energy = Math.min(100, user.energy + (user.fast.energyGain || 0));\n      user.cooldown = user.fast.turns || 1;\n    }\n  }\n  function canThrow(u) {\n    return (u.chargedMoves || []).some(m => u.energy >= (m.energyCost || 45));\n  }\n  function chooseThrow(u, foe) {\n    let pick = null,\n      best = -Infinity;\n    for (const m of u.chargedMoves || []) {\n      if (u.energy < (m.energyCost || 45)) continue;\n      const stab = u.types.includes(m.type) ? STAB : 1;\n      const mult = eff(m.type, foe.types);\n      const val = dmg(m.power, u.Atk, foe.Def, stab, mult);\n      if (val > best) {\n        best = val;\n        pick = m;\n      }\n    }\n    return pick;\n  }\n  function doThrow(attacker, defender, who) {\n    var _attacker$fast;\n    const move = chooseThrow(attacker, defender);\n    if (!move) return;\n    let shielded = false;\n    if (who === \"A\" ? shouldShield(attacker, defender, move, bSh) : shouldShield(attacker, defender, move, aSh)) {\n      if (who === \"A\") bSh--;else aSh--;\n      shielded = true;\n    } else {\n      const stab = attacker.types.includes(move.type) ? STAB : 1;\n      const mult = eff(move.type, defender.types);\n      const hit = dmg(move.power, attacker.Atk, defender.Def, stab, mult);\n      defender.HP = Math.max(0, defender.HP - hit);\n    }\n    attacker.energy -= move.energyCost || 45;\n    attacker.cooldown = ((_attacker$fast = attacker.fast) === null || _attacker$fast === void 0 ? void 0 : _attacker$fast.turns) || 1; // charged consumes the turn window\n    log.push(`${who} throws ${move.id}${shielded ? \" (shielded)\" : \"\"}`);\n  }\n\n  // initialize so a 1-turn fast \"lands\" on the first tick\n  A.cooldown = ((_A$fast = A.fast) === null || _A$fast === void 0 ? void 0 : _A$fast.turns) || 1;\n  B.cooldown = ((_B$fast = B.fast) === null || _B$fast === void 0 ? void 0 : _B$fast.turns) || 1;\n  while (A.HP > 0 && B.HP > 0 && t < MAX_TURNS) {\n    t++;\n\n    // 1) advance fast moves for BOTH sides (symmetry prevents 100â€“0s)\n    progressFast(A, B);\n    if (B.HP <= 0) break;\n    progressFast(B, A);\n    if (A.HP <= 0) break;\n\n    // 2) then check charged windows & resolve in CMP order\n    const aReady = canThrow(A);\n    const bReady = canThrow(B);\n    if (aReady || bReady) {\n      const aFirst = aReady && (!bReady || A.Atk >= B.Atk);\n      if (aFirst) {\n        doThrow(A, B, \"A\");\n        if (B.HP <= 0) break;\n        if (bReady) {\n          doThrow(B, A, \"B\");\n          if (A.HP <= 0) break;\n        }\n      } else {\n        doThrow(B, A, \"B\");\n        if (A.HP <= 0) break;\n        if (aReady) {\n          doThrow(A, B, \"A\");\n          if (B.HP <= 0) break;\n        }\n      }\n    }\n  }\n  const winner = A.HP <= 0 && B.HP <= 0 ? \"Draw\" : A.HP <= 0 ? B.name : B.HP <= 0 ? A.name : A.HP === B.HP ? \"Draw\" : A.HP > B.HP ? A.name : B.name;\n  return {\n    winner,\n    aHP: Math.round(A.HP / A.MaxHP * 100),\n    bHP: Math.round(B.HP / B.MaxHP * 100),\n    aRecommended: recA,\n    bRecommended: recB,\n    summary: log.slice(0, 12)\n  };\n}","map":{"version":3,"names":["bestCharged","att","def","best","bestVal","Infinity","m","chargedMoves","kind","stab","types","includes","type","STAB","mult","eff","val","dmg","power","Atk","Def","shouldShield","attacker","defender","incomingMove","shieldsLeft","hit","threshold","HP","MaxHP","simulateDuel","attackerIn","defenderIn","shieldsA","shieldsB","_book","MOVES","leagueName","_bestCharged","_bestCharged2","_A$fast","_B$fast","A","buildFighter","B","recA","id","recB","aSh","Math","max","bSh","t","MAX_TURNS","log","progressFast","user","foe","fast","cooldown","energy","min","energyGain","turns","canThrow","u","some","energyCost","chooseThrow","pick","doThrow","who","_attacker$fast","move","shielded","push","aReady","bReady","aFirst","winner","name","aHP","round","bHP","aRecommended","bRecommended","summary","slice"],"sources":["C:/Users/ben/Projects/nebsojipvptrainer/src/battleCalc.js"],"sourcesContent":["// pick charged with highest *actual* damage vs current foe (unchanged in your file)\r\nfunction bestCharged(att, def) {\r\n    let best = null, bestVal = -Infinity;\r\n    for (const m of (att.chargedMoves || [])) {\r\n        if (!m || m.kind !== \"charged\") continue;\r\n        const stab = att.types.includes(m.type) ? STAB : 1;\r\n        const mult = eff(m.type, def.types);\r\n        const val = dmg(m.power, att.Atk, def.Def, stab, mult);\r\n        if (val > bestVal) { bestVal = val; best = m; }\r\n    }\r\n    return best;\r\n}\r\n\r\n// --- FIX: estimate incoming damage with the *attacker's* stats/typing\r\nfunction shouldShield(attacker, defender, incomingMove, shieldsLeft) {\r\n    if (shieldsLeft <= 0) return false;\r\n    const stab = attacker.types.includes(incomingMove.type) ? STAB : 1;\r\n    const mult = eff(incomingMove.type, defender.types);\r\n    const hit = dmg(incomingMove.power, attacker.Atk, defender.Def, stab, mult);\r\n    const threshold = shieldsLeft === 2 ? 0.32 : 0.45; // tune if you like\r\n    return hit >= defender.HP || hit >= defender.MaxHP * threshold;\r\n}\r\n\r\nexport function simulateDuel(attackerIn, defenderIn, shieldsA = 2, shieldsB = 2, _book = MOVES, leagueName = \"Master League\") {\r\n    const A = buildFighter(attackerIn, leagueName);\r\n    const B = buildFighter(defenderIn, leagueName);\r\n\r\n    const recA = bestCharged(A, B)?.id || null;\r\n    const recB = bestCharged(B, A)?.id || null;\r\n\r\n    let aSh = Math.max(0, shieldsA | 0), bSh = Math.max(0, shieldsB | 0);\r\n    let t = 0; const MAX_TURNS = 2000; const log = [];\r\n\r\n    function progressFast(user, foe) {\r\n        if (!user.fast) return;\r\n        user.cooldown--;\r\n        if (user.cooldown <= 0) {\r\n            const stab = user.types.includes(user.fast.type) ? STAB : 1;\r\n            const mult = eff(user.fast.type, foe.types);\r\n            const hit = dmg(user.fast.power, user.Atk, foe.Def, stab, mult);\r\n            foe.HP = Math.max(0, foe.HP - hit);\r\n            user.energy = Math.min(100, user.energy + (user.fast.energyGain || 0));\r\n            user.cooldown = user.fast.turns || 1;\r\n        }\r\n    }\r\n\r\n    function canThrow(u) {\r\n        return (u.chargedMoves || []).some(m => u.energy >= (m.energyCost || 45));\r\n    }\r\n\r\n    function chooseThrow(u, foe) {\r\n        let pick = null, best = -Infinity;\r\n        for (const m of (u.chargedMoves || [])) {\r\n            if (u.energy < (m.energyCost || 45)) continue;\r\n            const stab = u.types.includes(m.type) ? STAB : 1;\r\n            const mult = eff(m.type, foe.types);\r\n            const val = dmg(m.power, u.Atk, foe.Def, stab, mult);\r\n            if (val > best) { best = val; pick = m; }\r\n        }\r\n        return pick;\r\n    }\r\n\r\n    function doThrow(attacker, defender, who) {\r\n        const move = chooseThrow(attacker, defender);\r\n        if (!move) return;\r\n        let shielded = false;\r\n        if (who === \"A\" ? shouldShield(attacker, defender, move, bSh)\r\n            : shouldShield(attacker, defender, move, aSh)) {\r\n            if (who === \"A\") bSh--; else aSh--;\r\n            shielded = true;\r\n        } else {\r\n            const stab = attacker.types.includes(move.type) ? STAB : 1;\r\n            const mult = eff(move.type, defender.types);\r\n            const hit = dmg(move.power, attacker.Atk, defender.Def, stab, mult);\r\n            defender.HP = Math.max(0, defender.HP - hit);\r\n        }\r\n        attacker.energy -= (move.energyCost || 45);\r\n        attacker.cooldown = attacker.fast?.turns || 1; // charged consumes the turn window\r\n        log.push(`${who} throws ${move.id}${shielded ? \" (shielded)\" : \"\"}`);\r\n    }\r\n\r\n    // initialize so a 1-turn fast \"lands\" on the first tick\r\n    A.cooldown = A.fast?.turns || 1;\r\n    B.cooldown = B.fast?.turns || 1;\r\n\r\n    while (A.HP > 0 && B.HP > 0 && t < MAX_TURNS) {\r\n        t++;\r\n\r\n        // 1) advance fast moves for BOTH sides (symmetry prevents 100â€“0s)\r\n        progressFast(A, B);\r\n        if (B.HP <= 0) break;\r\n        progressFast(B, A);\r\n        if (A.HP <= 0) break;\r\n\r\n        // 2) then check charged windows & resolve in CMP order\r\n        const aReady = canThrow(A);\r\n        const bReady = canThrow(B);\r\n        if (aReady || bReady) {\r\n            const aFirst = aReady && (!bReady || (A.Atk >= B.Atk));\r\n            if (aFirst) {\r\n                doThrow(A, B, \"A\");\r\n                if (B.HP <= 0) break;\r\n                if (bReady) {\r\n                    doThrow(B, A, \"B\");\r\n                    if (A.HP <= 0) break;\r\n                }\r\n            } else {\r\n                doThrow(B, A, \"B\");\r\n                if (A.HP <= 0) break;\r\n                if (aReady) {\r\n                    doThrow(A, B, \"A\");\r\n                    if (B.HP <= 0) break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const winner =\r\n        A.HP <= 0 && B.HP <= 0 ? \"Draw\" :\r\n            A.HP <= 0 ? B.name :\r\n                B.HP <= 0 ? A.name :\r\n                    (A.HP === B.HP ? \"Draw\" : (A.HP > B.HP ? A.name : B.name));\r\n\r\n    return {\r\n        winner,\r\n        aHP: Math.round((A.HP / A.MaxHP) * 100),\r\n        bHP: Math.round((B.HP / B.MaxHP) * 100),\r\n        aRecommended: recA,\r\n        bRecommended: recB,\r\n        summary: log.slice(0, 12),\r\n    };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}